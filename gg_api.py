'''Version 0.5'''

# Year of the Golden Globes ceremony being analyzed
YEAR = "2013"

# Global variable for hardcoded award names
# This list is used by get_nominees(), get_winner(), and get_presenters() functions
# as the keys for their returned dictionaries
# Students should populate this list with the actual award categories for their year, to avoid cascading errors on outputs that depend on correctly extracting award names (e.g., nominees, presenters, winner)
AWARD_NAMES = [
    "best screenplay - motion picture",
    "best director - motion picture",
    "best performance by an actress in a television series - comedy or musical",
    "best foreign language film",
    "best performance by an actor in a supporting role in a motion picture",
    "best performance by an actress in a supporting role in a series, mini-series or motion picture made for television",
    "best motion picture - comedy or musical",
    "best performance by an actress in a motion picture - comedy or musical",
    "best mini-series or motion picture made for television",
    "best original score - motion picture",
    "best performance by an actress in a television series - drama",
    "best performance by an actress in a motion picture - drama",
    "cecil b. demille award",
    "best performance by an actor in a motion picture - comedy or musical",
    "best motion picture - drama",
    "best performance by an actor in a supporting role in a series, mini-series or motion picture made for television",
    "best performance by an actress in a supporting role in a motion picture",
    "best television series - drama",
    "best performance by an actor in a mini-series or motion picture made for television",
    "best performance by an actress in a mini-series or motion picture made for television",
    "best animated feature film",
    "best original song - motion picture",
    "best performance by an actor in a motion picture - drama",
    "best television series - comedy or musical",
    "best performance by an actor in a television series - drama",
    "best performance by an actor in a television series - comedy or musical",
]

def _load_jsonl(path: str):
    rows = []
    try:
        with open(path, "r", encoding="utf-8") as f:
            for line in f:
                line = line.strip()
                if not line:
                    continue
                try:
                    rows.append(json.loads(line))
                except Exception:
                    pass
    except FileNotFoundError:
        print(f"could not find {path}; did pre_ceremony() run?")
    return rows

def get_hosts(year):
    '''Returns the host(s) of the Golden Globes ceremony for the given year.
    
    Args:
        year (str): The year of the Golden Globes ceremony (e.g., "2013")
    
    Returns:
        list: A list of strings containing the host names. 
              Example: ["Seth Meyers"] or ["Tina Fey", "Amy Poehler"]
    
    Note:
        - Do NOT change the name of this function or what it returns
        - The function should return a list even if there's only one host
    '''
    # Your code here
    from hosts import find_hosts

    # use the cleaned tweets generated by pre_ceremony()
    hosts = find_hosts("tweets_cleaned.jsonl")
    if not isinstance(hosts, list):
        hosts = [hosts] if hosts else []

    return hosts

def get_awards(year):
    '''Returns the list of award categories for the Golden Globes ceremony.
    
    Args:
        year (str): The year of the Golden Globes ceremony (e.g., "2013")
    
    Returns:
        list: A list of strings containing award category names.
              Example: ["Best Motion Picture - Drama", "Best Motion Picture - Musical or Comedy", 
                       "Best Performance by an Actor in a Motion Picture - Drama"]
    
    Note:
        - Do NOT change the name of this function or what it returns
        - Award names should be extracted from tweets, not hardcoded
        - The only hardcoded part allowed is the word "Best"
    '''
    # Your code here
    from nlp_pipeline.extract_awards import extract_awards
    data_path = "tweets_cleaned.jsonl"
    try:
        awards = extract_awards(data_path)
        if not awards:
            print("No awards extracted — using hardcoded AWARD_NAMES fallback.")
            awards = AWARD_NAMES
    except Exception as e:
        print(f"Error extracting awards: {e}")
        awards = AWARD_NAMES

def get_nominees(year):
    '''Returns the nominees for each award category.
    
    Args:
        year (str): The year of the Golden Globes ceremony (e.g., "2013")
    
    Returns:
        dict: A dictionary where keys are award category names and values are 
              lists of nominee strings.
              Example: {
                  "Best Motion Picture - Drama": [
                      "Three Billboards Outside Ebbing, Missouri",
                      "Call Me by Your Name", 
                      "Dunkirk",
                      "The Post",
                      "The Shape of Water"
                  ],
                  "Best Motion Picture - Musical or Comedy": [
                      "Lady Bird",
                      "The Disaster Artist",
                      "Get Out",
                      "The Greatest Showman",
                      "I, Tonya"
                  ]
              }
    
    Note:
        - Do NOT change the name of this function or what it returns
        - Use the hardcoded award names as keys (from the global AWARD_NAMES list)
        - Each value should be a list of strings, even if there's only one nominee
    '''
    # Your code here
    from nlp_pipeline.extract_nominees import extract_nominees
    tweets = _load_jsonl("tweets_cleaned.jsonl")
    awards_for_extractor = [a.strip().lower() for a in AWARD_NAMES]

    out = extract_nominees(
        tweets=tweets,
        award_names=awards_for_extractor,
        top_k=4,
        debug=False,
    )
    # ensure every award key exists even if empty
    return {aw: out.get(aw, []) for aw in awards_for_extractor}

def get_winner(year):
    '''Returns the winner for each award category.
    
    Args:
        year (str): The year of the Golden Globes ceremony (e.g., "2013")
    
    Returns:
        dict: A dictionary where keys are award category names and values are 
              single winner strings.
              Example: {
                  "Best Motion Picture - Drama": "Three Billboards Outside Ebbing, Missouri",
                  "Best Motion Picture - Musical or Comedy": "Lady Bird",
                  "Best Performance by an Actor in a Motion Picture - Drama": "Gary Oldman"
              }
    
    Note:
        - Do NOT change the name of this function or what it returns
        - Use the hardcoded award names as keys (from the global AWARD_NAMES list)
        - Each value should be a single string (the winner's name)
    '''
    # Your code here
    from nlp_pipeline.extract_winners import extract_winners
    tweets = _load_jsonl("tweets_cleaned.jsonl")
    awards_for_extractor = [a.strip().lower() for a in AWARD_NAMES]

    # run winner extractor (kept simple on purpose)
    raw_winners = extract_winners(
        tweets=tweets,
        award_names=awards_for_extractor,
        debug=False,
    )

    # make sure every key exists and every value is a string
    winners_out = {}
    for aw in awards_for_extractor:
        w = raw_winners.get(aw)
        if isinstance(w, str):
            winners_out[aw] = w
        elif isinstance(w, list) and w:
            winners_out[aw] = w[0]
        else:
            winners_out[aw] = ""
    return winners_out


def get_presenters(year):
    '''Returns the presenters for each award category.
    
    Args:
        year (str): The year of the Golden Globes ceremony (e.g., "2013")
    
    Returns:
        dict: A dictionary where keys are award category names and values are 
              lists of presenter strings.
              Example: {
                  "Best Motion Picture - Drama": ["Barbra Streisand"],
                  "Best Motion Picture - Musical or Comedy": ["Alicia Vikander", "Michael Keaton"],
                  "Best Performance by an Actor in a Motion Picture - Drama": ["Emma Stone"]
              }
    
    Note:
        - Do NOT change the name of this function or what it returns
        - Use the hardcoded award names as keys (from the global AWARD_NAMES list)
        - Each value should be a list of strings, even if there's only one presenter
    '''
    # Your code here
    from nlp_pipeline.extract_presenter import extract_presenters
    data_path = "tweets_cleaned.jsonl"
    presenters_out = extract_presenters(data_path, AWARD_NAMES)
    return {aw: presenters_out.get(aw, []) for aw in AWARD_NAMES}

def pre_ceremony():
    '''Pre-processes and loads data for the Golden Globes analysis.
    
    This function should be called before any other functions to:
    - Load and process the tweet data from gg2013.json
    - Download required models (e.g., spaCy models)
    - Perform any initial data cleaning or preprocessing
    - Store processed data in files or database for later use
    
    This is the first function the TA will run when grading.
    
    Note:
        - Do NOT change the name of this function or what it returns
        - This function should handle all one-time setup tasks
        - Print progress messages to help with debugging
    '''
    import io
    import json
    import re
    import zipfile
    from datetime import datetime
    from ftfy import fix_text
    import unidecode as _unidecode

    # look for raw data in the current directory
    input_candidates = ["gg2013.json.zip", "gg2013.json"]
    in_path = next((p for p in input_candidates if __import__("os").path.exists(p)), None)
    if in_path is None:
        print("WARNING: raw file not found. Put gg2013.json.zip or gg2013.json next to gg_api.py")
        return

    # regex + dash normalization (keep hyphens, standardize all dash variants to '-')
    url_re = re.compile(r"https?://\S+")
    mention_re = re.compile(r"@\w+")
    hashtag_re = re.compile(r"#\w+")
    dash_map = dict.fromkeys(map(ord, "–—‐−‒"), ord("-"))

    def _clean(text: str) -> str:
        if not text:
            return ""
        text = fix_text(text)
        text = _unidecode.unidecode(text)
        text = text.translate(dash_map)                 # keep hyphens
        text = url_re.sub("", text)
        text = re.sub(r"\brt\b", "", text, flags=re.IGNORECASE)
        text = mention_re.sub("", text)
        text = hashtag_re.sub("", text)
        # remove punctuation except hyphen-minus
        text = re.sub(r"[^A-Za-z0-9\s\-]", " ", text)
        text = " ".join(text.split())
        return text

    def _iter_records():
        if in_path.endswith(".zip"):
            with zipfile.ZipFile(in_path) as zf:
                inner = zf.namelist()[0]  # assume single JSON member
                with zf.open(inner, "r") as fh:
                    yield from json.load(io.TextIOWrapper(fh, encoding="utf-8"))
        else:
            with open(in_path, "r", encoding="utf-8") as fh:
                yield from json.load(fh)

    wrote = 0
    with open("tweets_cleaned.jsonl", "w", encoding="utf-8") as out:
        for t in _iter_records():
            raw_text = t.get("text") or ""
            cleaned = _clean(raw_text)

            ts_ms = t.get("timestamp_ms")
            try:
                ts_iso = datetime.fromtimestamp(int(ts_ms) / 1000.0).isoformat() if ts_ms else None
            except Exception:
                ts_iso = None

            rec = {
                "id": t.get("id"),
                "timestamp": ts_iso,
                "screen_name": (t.get("user") or {}).get("screen_name"),
                "user_id": (t.get("user") or {}).get("id"),
                "text": cleaned,           # cleaned, hyphen-preserved text for extraction
                "text_original": raw_text  # optional: for debugging
            }
            out.write(json.dumps(rec, ensure_ascii=False) + "\n")
            wrote += 1

    print(f"Pre-ceremony: wrote {wrote} cleaned tweets to tweets_cleaned.jsonl")
    print("Pre-ceremony processing complete.")
    return

import json

def main():
    '''Main function that orchestrates the Golden Globes analysis.
    
    This function should:
    - Call pre_ceremony() to set up the environment
    - Run the main analysis pipeline
    - Generate and save results in the required JSON format
    - Print progress messages and final results
    
    Usage:
        - Command line: python gg_api.py
        - Python interpreter: import gg_api; gg_api.main()
    
    This is the second function the TA will run when grading.
    
    Note:
        - Do NOT change the name of this function or what it returns
        - This function should coordinate all the analysis steps
        - Make sure to handle errors gracefully
    '''
    # run preprocessing first
    pre_ceremony()

    print("Extracting hosts...")
    hosts = get_hosts(YEAR)

    print("Extracting nominees...")
    nominees = get_nominees(YEAR)

    print("Extracting winners...")
    winners = get_winner(YEAR)

    print("Extracting presenters...")
    presenters = get_presenters(YEAR)

    output = {"Host": hosts, "Year": YEAR}
    for award in AWARD_NAMES:
        output[award] = {
            "Presenters": presenters.get(award, []),
            "Nominees": nominees.get(award, []),
            "Winner": winners.get(award, "")
        }

    with open("final_output.json", "w", encoding="utf-8") as f:
        json.dump(output, f, indent=2, ensure_ascii=False)

    nominees_filled = sum(1 for a in AWARD_NAMES if output[a]["Nominees"])
    winners_filled = sum(1 for a in AWARD_NAMES if output[a]["Winner"])
    print(f"wrote final_output.json — nominees found for {nominees_filled}/{len(AWARD_NAMES)}; winners found for {winners_filled}/{len(AWARD_NAMES)}.")

if __name__ == '__main__':
    main()
